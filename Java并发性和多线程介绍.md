<!-- GFM-TOC -->
* [1.Java并发性和多线程介绍](#1.Java并发性和多线程介绍)
* [2.多线程的优点](#2.多线程的优点)
* [3.多线程的代价](#3.多线程的代价)
* [4.并发编程模型](#4.并发编程模型)
* [5.如何创建并运行java线程](#5.如何创建并运行java线程)
* [6.竞态条件与临界区](#6.竞态条件与临界区)
* [7.线程安全与共享资源](#7.线程安全与共享资源)
* [8.线程安全及不可变性](#8.线程安全及不可变性)
* [9.Java内存模型](#9.Java内存模型)
* [10.JAVA同步块](#10.JAVA同步块)
* [11.线程通信](#11.线程通信)
* [12.Java ThreadLocal](#12.Java-ThreadLocal)
* [13.Thread Signaling](#13.Thread-Signaling)
* [14.死锁](#14.死锁)
* [15.避免死锁](#15.避免死锁)
* [16.饥饿和公平](#16.饥饿和公平)
* [17.嵌套管程锁死](#17.嵌套管程锁死)
* [18.Slipped Conditions](#18.Slipped-Conditions)
* [19.Java中的锁](#19.Java中的锁)
* [20.Java中的读/写锁](#20.Java中的读/写锁)
* [21.重入锁死](#21.重入锁死)
* [22.信号量](#22.信号量)
* [23.阻塞队列](#23.阻塞队列)
* [24.线程池](#24.线程池)
* [25.CAS](#25.CAS)
* [26.剖析同步器](#26.剖析同步器)
* [27.无阻塞算法](#27.无阻塞算法)
* [28.阿姆达尔定律](#28.阿姆达尔定律)
<!-- GFM-TOC -->

# 1.Java并发性和多线程介绍
在过去单CPU时代，单任务在一个时间点只能执行单一程序。之后发展到多任务阶段，计算机能在同一时间点并行执行多任务或多进程。虽然并不是真正意义上的“同一时间点”，而是多个任务或进程共享一个CPU，并交由操作系统来完成多任务间对CPU的运行切换，以使得每个任务都有机会获得一定的时间片运行。<br>

随着多任务对软件开发者带来的新挑战，程序不在能假设独占所有的CPU时间、所有的内存和其他计算机资源。一个好的程序榜样是在其不再使用这些资源时对其进行释放，以使得其他程序能有机会使用这些资源。<br>

再后来发展到多线程技术，使得在一个程序内部能拥有多个线程并行执行。一个线程的执行可以被认为是一个CPU在执行该程序。当一个程序运行在多线程下，就好像有多个CPU在同时执行该程序。<br>

多线程比多任务更加有挑战。多线程是在同一个程序内部并行执行，因此会对相同的内存空间进行并发读写操作。这可能是在单线程程序中从来不会遇到的问题。其中的一些错误也未必会在单CPU机器上出现，因为两个线程从来不会得到真正的并行执行。然而，更现代的计算机伴随着多核CPU的出现，也就意味着不同的线程能被不同的CPU核得到真正意义的并行执行。<br>

如果一个线程在读一个内存时，另一个线程正向该内存进行写操作，那进行读操作的那个线程将获得什么结果呢？是写操作之前旧的值？还是写操作成功之后的新值？或是一半新一半旧的值？或者，如果是两个线程同时写同一个内存，在操作完成后将会是什么结果呢？是第一个线程写入的值？还是第二个线程写入的值？还是两个线程写入的一个混合值？因此如没有合适的预防措施，任何结果都是可能的。而且这种行为的发生甚至不能预测，所以结果也是不确定性的。<br>
### Java的多线程和并发性
Java是最先支持多线程的开发的语言之一，Java从一开始就支持了多线程能力，因此Java开发者能常遇到上面描述的问题场景。这也是我想为Java并发技术而写这篇系列的原因。作为对自己的笔记，和对其他Java开发的追随者都可获益的。<br>

该系列主要关注Java多线程，但有些在多线程中出现的问题会和多任务以及分布式系统中出现的存在类似，因此该系列会将多任务和分布式系统方面作为参考，所以叫法上称为“并发性”，而不是“多线程”。<br>
# 2.多线程的优点
# 3.多线程的代价
# 4.并发编程模型
# 5.如何创建并运行java线程
# 6.竞态条件与临界区
# 7.线程安全与共享资源
# 8.线程安全及不可变性
# 9.Java内存模型
# 10.JAVA同步块
# 11.线程通信
# 12.Java ThreadLocal
# 13.Thread Signaling
# 14.死锁
# 15.避免死锁
# 16.饥饿和公平
# 17.嵌套管程锁死
# 18.Slipped Conditions
# 19.Java中的锁
# 20.Java中的读/写锁
# 21.重入锁死
# 22.信号量
# 23.阻塞队列
# 24.线程池
# 25.CAS
# 26.剖析同步器
# 27.无阻塞算法
# 28.阿姆达尔定律